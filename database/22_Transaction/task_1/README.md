# 課題1

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<details>
<summary>Table of Contents</summary>

- [デッドロックとは何か](#%E3%83%87%E3%83%83%E3%83%89%E3%83%AD%E3%83%83%E3%82%AF%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B)
- [ISOLATION LEVELとは何か](#isolation-level%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B)
- [行レベルロック、テーブルレベルロックの違いとは何か](#%E8%A1%8C%E3%83%AC%E3%83%99%E3%83%AB%E3%83%AD%E3%83%83%E3%82%AF%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E3%83%AC%E3%83%99%E3%83%AB%E3%83%AD%E3%83%83%E3%82%AF%E3%81%AE%E9%81%95%E3%81%84%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B)
- [悲観ロックと楽観ロックの違いは何か](#%E6%82%B2%E8%A6%B3%E3%83%AD%E3%83%83%E3%82%AF%E3%81%A8%E6%A5%BD%E8%A6%B3%E3%83%AD%E3%83%83%E3%82%AF%E3%81%AE%E9%81%95%E3%81%84%E3%81%AF%E4%BD%95%E3%81%8B)
- [ACIDモデル](#acid%E3%83%A2%E3%83%87%E3%83%AB)
  - [Atomicity (原子性)](#atomicity-%E5%8E%9F%E5%AD%90%E6%80%A7)
  - [Consistency (一貫性)](#consistency-%E4%B8%80%E8%B2%AB%E6%80%A7)
  - [Isolation (独立性)](#isolation-%E7%8B%AC%E7%AB%8B%E6%80%A7)
  - [Durability (耐久性)](#durability-%E8%80%90%E4%B9%85%E6%80%A7)
- [ロックの種類](#%E3%83%AD%E3%83%83%E3%82%AF%E3%81%AE%E7%A8%AE%E9%A1%9E)
  - [共有ロックと占有ロック](#%E5%85%B1%E6%9C%89%E3%83%AD%E3%83%83%E3%82%AF%E3%81%A8%E5%8D%A0%E6%9C%89%E3%83%AD%E3%83%83%E3%82%AF)
  - [Intention Locks](#intention-locks)

</details>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## デッドロックとは何か

デッドロックとは、2つ以上のトランザクションがお互いが必要としているデータを取得するために、お互いのリソースが解放されるのを待機している状況である。



## ISOLATION LEVELとは何か

## 行レベルロック、テーブルレベルロックの違いとは何か

## 悲観ロックと楽観ロックの違いは何か


## ACIDモデル

**ACIDモデル** とは、ビジネスデータやアプリケーションにとって重要となる **信頼性** の側面を重視したデータベースの設計原則である。

連続する複数の操作が

参考資料

- [15.2 InnoDB and the ACID Model](https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html)

### Atomicity (原子性)



### Consistency (一貫性)

### Isolation (独立性)

### Durability (耐久性)

## ロックの種類

### 共有ロックと占有ロック

InnoDBでは行レベルのロックとして **共有ロック (S)** と **占有ロック (X)** を実装している。

共有ロックは read lock とも呼ばれており、名前の通りテーブルからレコードをSELECT文で読み取るときに使用するロックである。

占有ロックは write lock とも呼ばれており、名前の通りテーブルから読み取ったレコードに対して更新や削除を行うときに使用するロックである。

とあるトランザクション T1 が行に対してロックを取得しているとき、ほかのトランザクション T2 が同じ行に対して取得できるロックは以下の組み合わせで表現できる。

|       |   S   |   X   |
| :---: | :---: | :---: |
|   S   |  Yes  |  No   |
|   X   |  No   |  No   |

つまりトランザクション T1 が共有ロックを取得している場合にのみ、ほかのトランザクション T2 は同じ行に対して共有ロックのみを取得することができる。

### Intention Locks

InnoDBでは、行ロックとテーブルロックの共存を可能にする、複数の粒度でのロックをサポートするために、 **インテンションロック** を採用している。

インテンションロックとは、テーブルレベルのロックであり、トランザクションがテーブル内の行に対して、**後から必要になる**ロックのタイプ（共有ロックや占有ロック）を表している。

| lock type                     | description                                                                              | SQL                     |
| :---------------------------- | :--------------------------------------------------------------------------------------- | :---------------------- |
| インテンション共有ロック (IS) | トランザクションがテーブルの行に対して**共有ロック**を設定**するつもり**であることを示す | `SELECT ... FOR SHARE`  |
| インテンション占有ロック (IX) | トランザクションがテーブルの行に対して**共有ロック**を設定**するつもり**であることを示す | `SELECT ... FOR UPDATE` |

インテンションロックを取得する流れとしては、トランザクションが共有ロックを行に対して**取得する前**に、トランザクションは**事前に**にテーブルに対してISロック、あるいはより強力なロックを取得しておく必要がある。

これは占有ロックの場合も同じであり、トランザクションが占有ロックを行に対して取得する前に、トランザクションは事前にテーブルに対してIXロックを取得しておく必要がある。

インテンションロックは、 `LOCK TABLES ... WRITE` のようにフルテーブルリクエストを除いてどのような操作もブロックしたりせず、あくまでもほかのユーザーに対して**これから取得するロックのタイプを示すだけ**である。


